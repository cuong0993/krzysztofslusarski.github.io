---
layout: default
title:  "[Java][JVM Logs][GC Logs] Monday with JVM logs - heap before GC"
date:   2021-07-18 09:51:30 +0100
---

# [Java][JVM Logs][GC Logs] Monday with JVM logs - heap before GC - is my heap wasted?

**article will be finished by 02.08.2021**

## GC logs

At the end of each _GC cycle_ you can find such an entry in GC logs at _info_ level:

```
GC(11536) Pause Young (Normal) (G1 Evacuation Pause) 6746M->2016M(8192M) 40.514ms
```

You can find **three** sizes in such an entry **A->B(C)** that are:
* **A** - used size of a heap before _GC cycle_
* **B** - used size of a heap after _GC cycle_
* **C** - current size of a whole heap

If we take the **A** value from each collection and put it on a chart we can generate _Heap before GC_ chart. From such a chart we can find out when our
_garbage collector_ starts its work.

Here is an example of such a chart from **G1** _collector_ (this chart is from **1 day** period):

![alt text](/assets/monday-3/7.jpg "7")

That's what we would like that graph to look like. Most of the _collections_ are done when the heap is almost full. That gap 
between the red, and the blue line is done by the **G1** setting called ```-XX:G1ReservePercent=10```. The value **10** is the
default value. This setting means that **G1** reserves **10%** of the whole heap as free, so it can copy living _Objects_ from _eden_ to _survivor_ space. 
Usually that graph looks like:

![alt text](/assets/monday-3/3.jpg "3")

![alt text](/assets/monday-3/2.jpg "2")

Each chart contains **three** groups of points. Let's focus on the second graph. Max heap size is **8GB**, and the **G1** starts:
* most of the time between **6GB** and **7GB**
* sometimes between **4GB** and **5GB**
* sometimes between **2,5GB** and **3,5GB**

The third group of _collections_ is done by a _concurrent_ part of **G1** (_concurrent start_, _remark_, _cleanup_ phases). 
It can be started before _eden_ is filled with _Objects_. The second group
is done by _mixed collections_. It is done by **G1** _ergonomics_ which shrinks the _young generation_ to handle _mixed collections_ within
**200ms** STW pause time (200ms is the default).

## Bad examples

![alt text](/assets/monday-3/5.jpg "5")

![alt text](/assets/monday-3/4.jpg "4")

Here are two applications that have a **12GB** heap but **G1** starts its work at **5GB** to **8B**. This is a bad result. **4GB** of the heap is wasted.

![alt text](/assets/monday-3/1.jpg "1")

Here is an application that has a **8GB** heap but **G1** starts its work completely randomly.

## Causes

For the **G1** most of the time the issue that causes such a behaviour is _humongous allocation_ which is a pain in the ass for every _collector_.

## JMX monitoring

The _Heap before GC_ chart can be generated by probing through JMX. You can generate it the same way as _Heap after GC_ but instead of
```#memoryUsageAfterGc``` you need to fetch ```#memoryUsageBeforeGc``` property. 






